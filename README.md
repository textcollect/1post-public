# 1post

#### Video Demo:  <URL HERE>
#### Description: A fully working simple, basic web application with the following layers:
* Persistence: MySQL Database.
* Backend: REST API with Java and Spring Boot.
* Frontend: JavaScript + CSS + HTML.

**Instructions**: 

**Building:**
To build the project, run the following in a terminal window from the root:
```sh
mvn clean install
```
Alternatively, `mvn clean package` works as well.

Note regarding difference between the 2 commands:
- `mvn clean package`: This command performs the same steps as `mvn package`, but it also cleans the project by removing any files generated by previous builds.

- `mvn clean install`: This command performs the same steps as `mvn clean package`, but it also installs the packaged artifact into your local Maven repository. This allows other projects to refer to it and use it as a dependency.

**Running:**
To run, type the following command in a terminal window from the root of the project folder:
```sh
java -jar target/onepost-0.0.1-SNAPSHOT.jar
```

<!-- Your README.md file should be minimally multiple paragraphs in length, and should explain what your project is, what each of the files you wrote for the project contains and does, and if you debated certain design choices, explaining why you made them. Ensure you allocate sufficient time and energy to writing a README.md that documents your project thoroughly. Be proud of it! If it is too short, the system will reject it. -->

**Introduction** : This web application project, 1post, is a text-only social networking site where users can only **post and reply _once a day_**. It is aimed primarily at people who wish to tell a short story within a 3000-characters limit. However there are no strict rules that dictate that users can only post short stories.

**Details**: For the backend of the web application (which we will refer to as "app" for short from here on), it was made using Java with the Spring Boot framework along with the application of some concepts of Model-View-Controller. A MySQL database was also used to store and retrieve information such as user details, their posts and replies.

#### Java
##### Repository
In the "entity" folder under the "repository" folder is the 3 entity classes that is used for the app. We have "Post", "Reply" and "User", each corresponding to their respective tables in the database. These classes are used to map against their respective tables in the database.

Outside of the "entity" folder, in the "repository" folder itself is the 3 repository classes, same as the entity classes. These repository classes are _interface_ classes that extends the CRUDRepository class provided by the Spring Boot framework. They allow us to access the methods that were already implemented by Spring to do "Create, Read, Update and Delete" functions on the data from the database.

In the ReplyRepository class, there is an additional method implmented that will be used to get the replies for a post based on the post_id. This is necessary to display on the frontend, as each post has their own indivdual page to load all the replies into.

Similarly. in the UserRepository class, there is a method to find a user's details from their username. This is to be used in another API endpoint in the UserController class.

##### Service
In the "service" folder, there are 2 classes for each entity. One is an interface class, while the other is the class that implments the interface class. The classes that implements the interface class are named like "PostServiceMySQL". These ServiceMySQL classes will be used in their respective controller classes to perform "Create, Read, Update and Delete" methods that come from the Repository class. 

As such, in simpler terms, the methods in these Service classes are calling the CRUD methods from their respective Repository class, essentially implementing the same CRUD methods by simply calling those methods from the Repository class. Here's an example:
```java
public Post save(Post post) {
    return this.postRepository.save(post);
	}
```

##### Controller
In the "dto" folder under the "Controller" folder are again the respective DTO (data transfer object) classes for each entity. It will interface with the Client (Browser) for any HTTP request (e.g. GET, POST, PUT, DELETE methods) and is wired to perform the "save" methods in the Controller class. 

As a side note, there are 2 User DTO classes, _UserRegisterDTO_ is for registering new users, which require all the information (such as username, password, email), while _UserDTO_ is going to be used in the Controller class to retrieve only all the usernames and id. Refer to the example below of one of the methods from one of the Controller classes.

In the "Controller" folder are again the 3 controller classes. These Controller classes are essentially the API endpoints that will be called in the frontend via Javascript to get the information needed to display on the webpage. The methods in the Controller classes calls the methods from the Service classes for the CRUD methods. Of note is the "save" method, which checks if the user has already made a post/reply in the last 24 hours and prevents the user from adding a new post/reply before then, thus the defining feature of this web application is implemented. (There is also a 30 minutes cooldown before each new user can be registered)

Here's an example:
```java
// API endpoint to return all products to the front-end
// frontend will issue a GET http request
@CrossOrigin
@GetMapping("/allpost")
public Iterable<Post> getPosts() {

    // return in the Controller represents a response to the Client
    return postService.all();
}

// The id value will be sent from the front-end through the API URL parameter
@CrossOrigin
@GetMapping("/{postId}")
public Post findPostById(@PathVariable Integer postId) {
    return postService.findById(postId);
}
```

Here's an example that uses the DTO class to save data passed from the frontend to the database:
```java
// Add & save new post using a PostService method
// which is linked to the Post table in db
@CrossOrigin
@PostMapping("/add")
public void save(@RequestParam(name = "postTitle", required = true) String postTitle,
                    @RequestParam(name = "postDescribe", required = true) String postDescribe,
                    @RequestParam(name = "postFull", required = true) String postFull,
                    @RequestParam(name = "postTime", required = false) LocalDateTime postTime,
//					 @RequestParam(name = "user_id", required = false) int user_id,
                    HttpServletRequest request) throws IOException {
    // Retrieve the currently logged-in user's username
    String username = request.getUserPrincipal().getName();

    // Retrieve the user_id from the database using the username
    Integer userId = jdbcTemplate.queryForObject("SELECT user_id FROM Users WHERE username = ?", new Object[]{username}, Integer.class);
    int userId2 = userId;
    /*
    In this line of code, `new Object[]{username}` is a vararg parameter that is passed to the `queryForObject` method as a parameterized SQL query. It specifies the value to be bound to the `?` placeholder in the query.
    In this case, the query is `"SELECT user_id FROM Users WHERE username = ?"`, and the value to be bound to the `?` is the `username` variable. So the query will retrieve the `user_id` from the `Users` table where the `username` column matches the value of the `username` variable.
    `Integer.class` specifies the expected type of the result, which is an integer value for the `user_id`. This tells the `queryForObject` method to return an object of type `Integer`.
    */
    LocalDateTime newPostTime = now() ;
    LocalDateTime prevPostTime = jdbcTemplate.queryForObject("SELECT MAX(postTime) FROM Post WHERE user_id=?", new Object[]{userId2}, LocalDateTime.class);
    if (prevPostTime == null) {
        // Create the PostDTO and save the Post
        PostDTO postDto = new PostDTO(postTitle, postDescribe, postFull, postTime, userId2);
        postService.save(new Post(postDto));

    } else if (prevPostTime.plusDays(1).isBefore(newPostTime)) {
        PostDTO postDto = new PostDTO(postTitle, postDescribe, postFull, postTime, userId2);
        postService.save(new Post(postDto));

    } else {
        throw new IOException("Error adding new post. It has not been more than 24 hours since last post.");
    }
}
```

##### Security
In the "Security" folder are the classes that handles the authentication methods and "view" for the end-user. 

The MvcConfig class has a method to map the browser's URL to a specific View (HTML) inside the (/resources/templates) directory, while the _addResourceHandler_ method is used to specify the path to serve the static contents (js, css, images) from (i.e. /static), this returns a _ResourceHandlerRegistration_ object, which is used to add one or more locations
from which to serve static content from (i.e. classpath:/static/ in this case). Finally, _setCachePeriod(0)_ is used to prevent caching of any content in the browser.

The WebSecurityConfig class is used to define the methods for authenticating the user (jdbc is used as the authentication manager).

Finally, the _filterChain_ method defines the access permissions for the webpages and API endpoints based on the user's "Role" as specified in the User table in the database and restrict certain pages to only allow user's who are logged-in (i.e. authenticated). This method also defines the pages for login and redirects the user to a specific page when loin is successful.

----------------
#### Frontend
The frontend is done with HTML, some simple CSS and Javascript, making use of the Bootstrap library and Thymeleaf template engine for interactiveness with the backend.

In the [/templates/common] folder are the common elements such as navbar, footer that are inserted into every webpage. Meanwhile, in the [/templates/homepage] folder is the content that will be inserted into the homepage (index.html).

Certain html files like [postForm, postlist, registerNewPerson, showPostDetail] have javascript files linked to them to either display the content fetched from the database or to handle the logic of sending data back to the database (via their respective APIs). As the _controller_ and _form_ javascripts for multiple entities are somewhat similar, let's just pick one from each and give a brief description.

Firstly, _postController.js_. This file contains the methods for getting the post data via the API, putting them into an array and displaying them on _postList.html_ by order of newest to oldest. It also fetches all users' id and username (just these 2) so that the user that made the post is linked to the post and we can display the post's creator's username along with the date and time of the post. 

There might have been a better way to implement this without fetching a list of all users' id along with their username. Maybe we could have called the API on each post and fetch the respective post's username using the post's userid. But that would have meant multiple calls of that API, hence this implementation was what was settled on.

There is also the function to add a new post using data the user submitted from the _postForm.html_ and call the API for POST-ing this information to the backend and database. The function will display respective prompts for the errors that might occur when adding a new post with the relevant explanations.

In _postForm.js_ is the method for fetching the data the user submitted through the form at _postForm.html_. It contains the logic for checking and ensuring the data satisfies the requirements (i.e. does not exceed a certain amount of characters). If the data does not satisfy the requirements, the post will not be added and the function to submit a new post via the API will not be called.

_postListing.js, postForm.js, replyListing.js_ and _replyForm.js_ simply calls the respective relevant functions from the repective Controller js files.

Finally, making use of the Thymeleaf template engine, certain site features such as posting and adding a new reply are hidden and inaccessible from unauthorised users (i.e. users not logged-in). This works in-hand with the WebSecurityConfig java class in the backend which prevents unauthorised users from accessing the APIs for POST methods. This way, even if someone were to use the relevant API without the neccessary authorisation, they will not be able to access the API.


________________
## Credits

Icons used:
* https://www.freepik.com/free-icon/speak_15502097.htm#page=2&position=40&from_view=search

Images used:
* https://unsplash.com/photos/b4s7eitmEqs
* https://unsplash.com/photos/6-zLzaQd2uk
* https://unsplash.com/photos/oLthDWAG244
* https://icons.getbootstrap.com/icons/chat-left-dots/